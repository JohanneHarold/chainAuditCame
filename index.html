<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consensus Chronicle</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Crimson Text', Georgia, serif; background: #050507; color: #f0ede5; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: rgba(10,10,15,0.8); }
    ::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #d4af37 0%, #8b6914 100%); border-radius: 3px; }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    @keyframes glow { 0%, 100% { filter: drop-shadow(0 0 3px rgba(212,175,55,0.4)); } 50% { filter: drop-shadow(0 0 12px rgba(212,175,55,0.7)); } }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95) translateY(-10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95) translateY(-10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    .shimmer-bg { background: linear-gradient(90deg, transparent, rgba(212,175,55,0.08), transparent); background-size: 200% 100%; animation: shimmer 3s infinite; }
    .float-anim { animation: float 4s ease-in-out infinite; }
    .glow-icon { animation: glow 2s ease-in-out infinite; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 60,
      VOTE_DURATION: 20,
      TOTAL_ROUNDS: 5,
      ROOM_TIMEOUT_AI: 60000,
      ROOM_TIMEOUT_CLOSE: 120000,
      ROOM_CREATE_COOLDOWN: 120000,
      GENLAYER_CONTRACT: '0x41Bed498EaA267D5E770bC6B5521721f16FB9143',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle"
      }
    };

    const C = {
      bg: '#050507', bgDeep: '#020203', bgCard: 'rgba(15,15,20,0.95)', bgGlass: 'rgba(255,255,255,0.03)',
      gold: '#d4af37', goldBright: '#f5d76e', goldLight: '#e8d48b', goldDark: '#8b6914', goldMuted: 'rgba(212,175,55,0.5)',
      text: '#f0ede5', textSoft: '#c5c0b5', textMuted: '#8a857a',
      border: 'rgba(212,175,55,0.25)', borderLight: 'rgba(212,175,55,0.12)',
      success: '#8bc34a', error: '#ef5350', optA: '#c62828', optALight: '#ef5350', optB: '#1565c0', optBLight: '#42a5f5'
    };

    const THEMES = {
      fantasy: { name: 'The Dragon\'s Awakening', icon: 'üêâ', tagline: 'Ancient prophecy unfolds...', opening: 'The ancient prophecy has come true ‚Äî the Black Dragon awakens after a thousand years. The kingdom stands at the precipice. Heroes are summoned to determine the fate of all...', rounds: [{ context: 'The dragon\'s shadow looms. A decision must be made before dawn.', a: { text: 'March to the dragon\'s lair. Strike before it regains full power.', tag: 'Strike' }, b: { text: 'Seek the ancient Elves. They sealed this evil once before.', tag: 'Allies' } }, { context: 'The path reveals new challenges. The council reconvenes.', a: { text: 'Press forward with force. Fortune favors the bold.', tag: 'Bold' }, b: { text: 'Gather more allies. United we stand stronger.', tag: 'Unite' } }, { context: 'A moment of truth. Every soul watches with bated breath.', a: { text: 'Invoke forbidden arts. Some must fall so others survive.', tag: 'Sacrifice' }, b: { text: 'Hold our strength. The right moment will come.', tag: 'Wait' } }, { context: 'The battle reaches its peak. Heroes rise and fall.', a: { text: 'Launch the final assault. All or nothing.', tag: 'Attack' }, b: { text: 'Seek parley with the beast. Perhaps there is another way.', tag: 'Negotiate' } }, { context: 'The final choice. History will remember this moment.', a: { text: 'Destroy the dragon at any cost.', tag: 'Victory' }, b: { text: 'Forge an alliance. A new era begins.', tag: 'Peace' } }], endings: { default: 'Through fire and shadow, the heroes forged their legend. This tale shall echo through the ages.' } },
      scifi: { name: 'The Last Signal', icon: 'üåå', tagline: 'Humanity\'s darkest hour...', opening: 'Year 2157. Mars Colony receives a signal ‚Äî Earth will be struck by an asteroid in 100 days. Resources can save only half. The countdown begins...', rounds: [{ context: 'Panic spreads. Leadership must act now.', a: { text: 'Initiate Ark Protocol. A lottery decides who lives.', tag: 'Lottery' }, b: { text: 'Decode the signal\'s origin. Answers may await in the stars.', tag: 'Explore' } }, { context: 'New information emerges. Every decision carries weight.', a: { text: 'Prioritize essential personnel for maximum survival.', tag: 'Elite' }, b: { text: 'Every life has equal worth. Random selection.', tag: 'Equal' } }, { context: 'Resources dwindle. Tensions rise.', a: { text: 'Implement martial law. Order must be maintained.', tag: 'Control' }, b: { text: 'Trust humanity. Maintain freedoms.', tag: 'Freedom' } }, { context: 'Contact with alien intelligence. Their offer has strings.', a: { text: 'Accept their terms. Survival first.', tag: 'Accept' }, b: { text: 'Reject. We find our own path.', tag: 'Reject' } }, { context: 'Final countdown. One last chance.', a: { text: 'All power to deflection. Maximum risk.', tag: 'Gambit' }, b: { text: 'Preserve what we can. Humanity will rebuild.', tag: 'Preserve' } }], endings: { default: 'In the darkness between stars, humanity faced its greatest test. Whatever was chosen, it was chosen together.' } },
      mystery: { name: 'The Chen Manor Case', icon: 'üóùÔ∏è', tagline: 'Secrets in shadow...', opening: 'A storm rages outside Chen Manor. The patriarch lies dead ‚Äî poisoned. Door locked from within. Five souls remain, each with secrets darker than the night...', rounds: [{ context: 'Investigation begins. Every moment counts.', a: { text: 'Search the study. Evidence never lies.', tag: 'Evidence' }, b: { text: 'Interview suspects. Watch their eyes.', tag: 'Interview' } }, { context: 'First clues emerge. Multiple threads appear.', a: { text: 'Follow the money. Inheritance corrupts.', tag: 'Money' }, b: { text: 'Investigate the stranger. Too convenient.', tag: 'Stranger' } }, { context: 'Plot thickens. Nothing is as it seems.', a: { text: 'Verify alibis. Someone will crack.', tag: 'Alibis' }, b: { text: 'Dig into the past. Old sins cast shadows.', tag: 'Past' } }, { context: 'Truth surfaces. Resistance grows.', a: { text: 'Confront the prime suspect directly.', tag: 'Confront' }, b: { text: 'Re-examine the poison. Weapon reveals all.', tag: 'Forensic' } }, { context: 'Justice awaits. Truth stands revealed.', a: { text: 'Expose everything. Let law decide.', tag: 'Justice' }, b: { text: 'Some truths destroy. Perhaps mercy serves better.', tag: 'Mercy' } }], endings: { default: 'Justice took its form within these walls. The truth now stands in light, but some wounds may never heal.' } },
      political: { name: 'The Succession', icon: '‚öîÔ∏è', tagline: 'Every crown has its price...', opening: 'The Emperor has drawn his last breath. His edict: the throne passes to "whoever best serves the will of heaven." Three princes. One crown. Countless schemes...', rounds: [{ context: 'The court holds its breath. Factions emerge.', a: { text: 'Support the Crown Prince. Honor tradition.', tag: 'Tradition' }, b: { text: 'Propose merit selection. Let deeds decide.', tag: 'Merit' } }, { context: 'Alliances shift. Power consolidates.', a: { text: 'Secure military loyalty. Swords keep peace.', tag: 'Military' }, b: { text: 'Win the scholars. Pens shape history.', tag: 'Scholars' } }, { context: 'External forces sense weakness.', a: { text: 'Display strength at borders.', tag: 'Strength' }, b: { text: 'Pursue diplomatic peace.', tag: 'Diplomacy' } }, { context: 'Internal strife threatens the realm.', a: { text: 'Eliminate opposition. Mercy is weakness.', tag: 'Ruthless' }, b: { text: 'Seek compromise. United we stand.', tag: 'Balance' } }, { context: 'The moment of truth. Dynasty\'s fate awaits.', a: { text: 'Establish new order. Old ways failed.', tag: 'Revolution' }, b: { text: 'Preserve what works. Evolve gradually.', tag: 'Evolution' } }], endings: { default: 'The game of thrones spares none. In pursuit of power, some found glory, others ruin. But the realm endures.' } }
    };

    const AI_PLAYERS = [
      { id: 'ai_sage', name: 'Sage Iris', avatar: 'üîÆ', exp: 0, isAI: true, style: 'analytical' },
      { id: 'ai_knight', name: 'Sir Kane', avatar: '‚öîÔ∏è', exp: 0, isAI: true, style: 'bold' },
      { id: 'ai_scholar', name: 'Scholar Noah', avatar: 'üìú', exp: 0, isAI: true, style: 'cautious' }
    ];

    const genAIDebate = (style) => {
      const d = { analytical: { A: ['Logic favors A.', 'Evidence points to A.'], B: ['Analysis shows B optimal.', 'B yields better outcomes.'] }, bold: { A: ['Fortune favors bold! A!', 'No hesitation - A!'], B: ['True courage is B!', 'B is the warrior\'s path!'] }, cautious: { A: ['Risky, but A may work.', 'Lesser evil - support A.'], B: ['Wisdom says B.', 'B preserves options.'] } };
      const c = Math.random() > 0.5 ? 'A' : 'B';
      return { text: (d[style]?.[c] || d.analytical[c])[Math.floor(Math.random() * 2)], choice: c };
    };

    const S = {
      title: { fontFamily: "'Cinzel', serif", letterSpacing: '0.1em', fontWeight: 600 },
      card: { background: C.bgCard, border: `1px solid ${C.border}`, borderRadius: '12px', boxShadow: '0 8px 32px rgba(0,0,0,0.4)' },
      btn: { fontFamily: "'Cinzel', serif", fontWeight: 600, letterSpacing: '0.05em', transition: 'all 0.3s', cursor: 'pointer' },
      goldBtn: { background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, color: '#0a0a0a', border: 'none' },
      ghostBtn: { background: 'transparent', border: `1px solid ${C.border}`, color: C.goldMuted }
    };

    // Custom Modal Component
    const Modal = ({ show, title, message, onClose, onConfirm, type = 'info' }) => {
      if (!show) return null;
      const icons = { info: 'üìú', warning: '‚ö†Ô∏è', error: '‚ùå', success: '‚ú®', confirm: '‚ùì' };
      return (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.85)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 9999, padding: '1rem', backdropFilter: 'blur(5px)' }}>
          <div style={{ ...S.card, padding: '2rem', maxWidth: '420px', width: '100%', textAlign: 'center', animation: 'fadeIn 0.3s ease-out' }}>
            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>{icons[onConfirm ? 'confirm' : type]}</div>
            <h3 style={{ ...S.title, color: C.gold, fontSize: '1.2rem', marginBottom: '1rem' }}>{title}</h3>
            <p style={{ color: C.textSoft, lineHeight: 1.7, marginBottom: '1.5rem', fontSize: '0.95rem' }}>{message}</p>
            {onConfirm ? (
              <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center' }}>
                <button onClick={onClose} style={{ ...S.btn, ...S.ghostBtn, padding: '0.8rem 2rem', borderRadius: '8px', fontSize: '0.95rem' }}>Cancel</button>
                <button onClick={onConfirm} style={{ ...S.btn, ...S.goldBtn, padding: '0.8rem 2rem', borderRadius: '8px', fontSize: '0.95rem' }}>Confirm</button>
              </div>
            ) : (
              <button onClick={onClose} style={{ ...S.btn, ...S.goldBtn, padding: '0.8rem 2.5rem', borderRadius: '8px', fontSize: '0.95rem' }}>Understood</button>
            )}
          </div>
        </div>
      );
    };

    function App() {
      const [db, setDb] = useState(null);
      const [wallet, setWallet] = useState(null);
      const [connecting, setConnecting] = useState(false);
      const [showRules, setShowRules] = useState(false);
      const [tab, setTab] = useState('chronicles');
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'üé≠', exp: 0 });
      const [roomId, setRoomId] = useState(null);
      const [activeGameId, setActiveGameId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [game, setGame] = useState(null);
      const [msgs, setMsgs] = useState([]);
      const [rooms, setRooms] = useState([]);
      const [input, setInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [roomTimer, setRoomTimer] = useState(120);
      const [lb, setLb] = useState([]);
      const [hist, setHist] = useState([]);
      const [loading, setLoading] = useState(false);
      const [modal, setModal] = useState({ show: false, title: '', message: '', type: 'info', onConfirm: null });
      const timerRef = useRef(null);
      const roomTimerRef = useRef(null);
      const msgsEndRef = useRef(null);
      const roomChkRef = useRef(null);
      const lastRoundRef = useRef(0);
      const scoredRoundRef = useRef(0);
      const debatedRoundRef = useRef(0);
      const processingRef = useRef(false);
      const roomClosedShownRef = useRef(false);
      const gameRef = useRef(null);
      const modalShownRef = useRef(false);
      const intentionalExitRef = useRef(false);
      const exitingRef = useRef(false); // Track if currently exiting
      
      // Full state reset function
      const fullReset = () => {
        // Clear all timers
        if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
        if (roomChkRef.current) { clearInterval(roomChkRef.current); roomChkRef.current = null; }
        if (roomTimerRef.current) { clearInterval(roomTimerRef.current); roomTimerRef.current = null; }
        
        // Clear active game tracking
        setActiveGameId(null);
        localStorage.removeItem('cc_activegame');
        
        // Clear room/game state
        setRoomId(null);
        setRoomData(null);
        setGame(null);
        gameRef.current = null;
        setPlayers([]);
        setMsgs([]);
        setMyVote(null);
        setRoomTimer(120);
        
        // Reset all refs EXCEPT intentionalExitRef and exitingRef
        lastRoundRef.current = 0;
        scoredRoundRef.current = 0;
        debatedRoundRef.current = 0;
        processingRef.current = false;
        roomClosedShownRef.current = false;
        modalShownRef.current = false;
        
        // Reset loading state - CRITICAL for re-entry
        setLoading(false);
        
        // Close any open modals
        setModal({ show: false, title: '', message: '', type: 'info', onConfirm: null });
        
        // Return to home view
        setView('home');
        
        // Reset exit flags AFTER a delay to ensure Firebase listeners have cleaned up
        setTimeout(() => {
          intentionalExitRef.current = false;
          exitingRef.current = false;
        }, 500);
      };

      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          const database = firebase.database();
          setDb(database);
          database.ref('players').on('value', s => {
            if (s.val()) {
              const list = Object.entries(s.val()).map(([id, p]) => ({ ...p, id })).filter(p => (p.exp || 0) > 0).sort((a, b) => (b.exp || 0) - (a.exp || 0));
              setLb(list.slice(0, 50));
            } else setLb([]);
          });
        } catch (e) { console.error(e); }
        const sw = localStorage.getItem('cc_wallet');
        const sp = localStorage.getItem('cc_player');
        const sg = localStorage.getItem('cc_activegame');
        if (sw && sp) { try { setWallet(sw); setPlayer(JSON.parse(sp)); } catch {} }
        if (sg) setActiveGameId(sg);
        if (window.ethereum && sw) { window.ethereum.request({ method: 'eth_accounts' }).then(a => { if (a[0]?.toLowerCase() === sw.toLowerCase()) setWallet(a[0]); }); }
        return () => { if (timerRef.current) clearInterval(timerRef.current); if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, []);

      useEffect(() => {
        if (!db || !wallet) return;
        const ref = db.ref(`players/${wallet}`);
        ref.on('value', s => {
          const data = s.val();
          if (data?.exp !== undefined) {
            setPlayer(prev => { const u = { ...prev, exp: data.exp, name: data.name || prev.name, avatar: data.avatar || prev.avatar }; localStorage.setItem('cc_player', JSON.stringify(u)); return u; });
          }
        });
        return () => ref.off();
      }, [db, wallet]);

      useEffect(() => {
        if (!db || !wallet) return;
        const ref = db.ref(`userHistory/${wallet}`);
        ref.orderByChild('timestamp').limitToLast(50).on('value', s => { if (s.val()) setHist(Object.values(s.val()).sort((a, b) => b.timestamp - a.timestamp)); else setHist([]); });
        return () => ref.off();
      }, [db, wallet]);

      // Load rooms - only show waiting rooms that are not expired
      useEffect(() => {
        if (!db) return;
        const ref = db.ref('rooms');
        ref.on('value', s => {
          const d = s.val();
          const now = Date.now();
          if (d) {
            const r = [];
            Object.entries(d).forEach(([id, rm]) => {
              // Only show waiting rooms that haven't expired
              if (rm.status === 'waiting' && (now - rm.createdAt) < CONFIG.ROOM_TIMEOUT_CLOSE) {
                r.push({ id, ...rm });
              }
              // Auto-close expired waiting rooms (not playing/ended rooms)
              if (rm.status === 'waiting' && (now - rm.createdAt) >= CONFIG.ROOM_TIMEOUT_CLOSE) {
                db.ref(`rooms/${id}`).update({ status: 'expired' });
              }
            });
            setRooms(r);
          } else setRooms([]);
        });
        return () => ref.off();
      }, [db]);

      useEffect(() => {
        if (!db || !roomId) return;
        roomClosedShownRef.current = false;
        const rRef = db.ref(`rooms/${roomId}`);
        const gRef = db.ref(`games/${roomId}`);
        
        const rh = s => {
          const d = s.val();
          if (d) {
            setRoomData(d);
            if (d.players) setPlayers(Object.values(d.players));
            // If room is closed/expired, check game state directly from Firebase
            // Skip if this is an intentional exit (user clicked Leave)
            if ((d.status === 'closed' || d.status === 'expired') && !roomClosedShownRef.current && !intentionalExitRef.current) {
              gRef.once('value').then(gs => {
                const gd = gs.val();
                if (!gd || gd.phase !== 'ended') {
                  roomClosedShownRef.current = true;
                  setActiveGameId(null);
                  localStorage.removeItem('cc_activegame');
                  showModal('üìú Room Closed', 'This chronicle room is no longer available.');
                  resetSync();
                }
              });
            }
            if (d.status === 'playing') {
              setView('game');
              setMyVote(null);
            }
          }
        };
        
        const gh = s => {
          const d = s.val();
          if (d) {
            gameRef.current = d;
            setGame(d);
            if (d.messages) setMsgs(Object.values(d.messages).sort((a, b) => a.timestamp - b.timestamp));
            if (d.round !== lastRoundRef.current) { lastRoundRef.current = d.round; setMyVote(null); }
            if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000)));
          }
        };
        
        rRef.on('value', rh);
        gRef.on('value', gh);
        return () => { rRef.off('value', rh); gRef.off('value', gh); };
      }, [db, roomId]);

      useEffect(() => {
        if (!db || !roomId || !roomData || roomData.status !== 'waiting') return;
        if (roomChkRef.current) clearInterval(roomChkRef.current);
        roomChkRef.current = setInterval(() => {
          const age = Date.now() - roomData.createdAt;
          const realCnt = Object.values(roomData.players || {}).filter(p => !p.isAI).length;
          if (age > CONFIG.ROOM_TIMEOUT_AI && realCnt === 1 && player.id === roomData.host) {
            const curIds = Object.keys(roomData.players || {});
            AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, CONFIG.ROOM_SIZE.min - 1).forEach((ai, i) => { setTimeout(() => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai), i * 800); });
          }
        }, 5000);
        return () => { if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, [db, roomId, roomData, player.id]);

      // Room countdown timer (2 minutes to start game)
      useEffect(() => {
        if (view !== 'room' || !roomData || roomData.status !== 'waiting') {
          if (roomTimerRef.current) { clearInterval(roomTimerRef.current); roomTimerRef.current = null; }
          return;
        }
        
        if (roomTimerRef.current) clearInterval(roomTimerRef.current);
        
        // Initial calculation
        const calcRemaining = () => Math.max(0, 120 - Math.floor((Date.now() - roomData.createdAt) / 1000));
        setRoomTimer(calcRemaining());
        
        roomTimerRef.current = setInterval(() => {
          const rem = calcRemaining();
          setRoomTimer(rem);
        }, 1000);
        
        return () => { if (roomTimerRef.current) { clearInterval(roomTimerRef.current); roomTimerRef.current = null; } };
      }, [view, roomData]);

      useEffect(() => {
        // Single timer that runs throughout the game
        if (!db || !roomId) return;
        
        if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
        
        timerRef.current = setInterval(() => {
          const g = gameRef.current;
          if (!g || !g.timerEnd || g.phase === 'ended') {
            setTimer(0);
            return;
          }
          
          const rem = Math.max(0, Math.floor((g.timerEnd - Date.now()) / 1000));
          setTimer(rem);
          
          // Only host triggers phase transitions
          if (rem <= 0 && player.id === roomData?.host && !processingRef.current) {
            phaseEnd();
          }
        }, 1000);
        
        return () => { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } };
      }, [db, roomId, player.id, roomData?.host]);

      useEffect(() => { msgsEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [msgs]);

      const connectWallet = async () => {
        if (!window.ethereum) { showModal('ü¶ä MetaMask Required', 'Please install MetaMask browser extension to connect your wallet and play.'); return null; }
        setConnecting(true);
        try {
          const accs = await window.ethereum.request({ method: 'eth_requestAccounts' });
          const addr = accs[0];
          setWallet(addr);
          localStorage.setItem('cc_wallet', addr);
          if (db) {
            const snap = await db.ref(`players/${addr}`).once('value');
            const saved = snap.val();
            if (saved) {
              const p = { id: addr, name: saved.name || '', avatar: saved.avatar || 'üé≠', exp: saved.exp || 0 };
              setPlayer(p);
              localStorage.setItem('cc_player', JSON.stringify(p));
            } else {
              setPlayer(p => ({ ...p, id: addr, exp: 0 }));
            }
          }
          return addr;
        } catch { showModal('‚ùå Connection Failed', 'Failed to connect wallet. Please try again or check MetaMask.'); return null; }
        finally { setConnecting(false); }
      };

      const disconnect = () => {
        setWallet(null);
        setPlayer({ id: '', name: '', avatar: 'üé≠', exp: 0 });
        setActiveGameId(null);
        localStorage.removeItem('cc_wallet');
        localStorage.removeItem('cc_player');
        localStorage.removeItem('cc_activegame');
      };

      const showModal = (title, message, typeOrCallback = 'info') => {
        if (typeof typeOrCallback === 'function') {
          setModal({ show: true, title, message, type: 'confirm', onConfirm: typeOrCallback });
        } else {
          setModal({ show: true, title, message, type: typeOrCallback, onConfirm: null });
        }
      };

      const closeModal = () => {
        modalShownRef.current = false;
        setModal({ show: false, title: '', message: '', type: 'info', onConfirm: null });
      };

      const payFee = async (addr) => {
        if (!window.ethereum) {
          showModal('ü¶ä MetaMask Required', 'Please install MetaMask to proceed.');
          return false;
        }
        setLoading(true);
        try {
          await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: addr, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x' }] });
          return true;
        } catch (e) {
          console.log('Transaction cancelled or failed');
          return false;
        } finally {
          setLoading(false);
        }
      };

      const recordToGL = async () => {
        if (!wallet || !window.ethereum) return;
        try { await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: wallet, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x01' }] }); } catch {}
      };

      const createRoom = async (theme) => {
        // Validation
        if (!db) { showModal('‚ö†Ô∏è Error', 'Database not connected. Please refresh the page.'); return; }
        if (!player.name) { showModal('‚ö†Ô∏è Notice', 'Please enter your name first to begin your chronicle.'); return; }
        if (loading) { console.log('Already loading, skip'); return; }
        if (exitingRef.current) { console.log('Still exiting previous game, please wait'); return; }
        
        // Get wallet address
        let addr = wallet;
        if (!addr) { 
          addr = await connectWallet(); 
          if (!addr) return; 
        }
        
        // GenLayer transaction (burns GEN token)
        const paid = await payFee(addr);
        if (!paid) {
          console.log('Payment not completed');
          return;
        }
        
        // Create room in Firebase
        try {
          const now = Date.now();
          const rid = `room_${now}`;
          await db.ref(`rooms/${rid}`).set({
            theme,
            host: addr,
            status: 'waiting',
            createdAt: now,
            players: { [addr]: { id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } }
          });
          
          // Update local state
          setRoomId(rid);
          setActiveGameId(rid);
          localStorage.setItem('cc_activegame', rid);
          setView('room');
        } catch (e) {
          console.error('Create room failed:', e);
          setLoading(false);
          showModal('‚ö†Ô∏è Error', 'Failed to create room. Please try again.');
        }
      };

      const joinRoom = async (rid) => {
        // Validation
        if (!db) { showModal('‚ö†Ô∏è Error', 'Database not connected. Please refresh the page.'); return; }
        if (!player.name) { showModal('‚ö†Ô∏è Notice', 'Please enter your name first to join a chronicle.'); return; }
        if (loading) { console.log('Already loading, skip'); return; }
        if (exitingRef.current) { console.log('Still exiting previous game, please wait'); return; }
        
        // Get wallet address
        let addr = wallet;
        if (!addr) { 
          addr = await connectWallet(); 
          if (!addr) return; 
        }
        
        // GenLayer transaction (burns GEN token)
        const paid = await payFee(addr);
        if (!paid) {
          console.log('Payment not completed');
          return;
        }
        
        // Join room in Firebase
        try {
          await db.ref(`rooms/${rid}/players/${addr}`).set({ id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
          setRoomId(rid);
          setActiveGameId(rid);
          localStorage.setItem('cc_activegame', rid);
          setView('room');
        } catch (e) {
          console.error('Join room failed:', e);
          setLoading(false);
          showModal('‚ö†Ô∏è Error', 'Failed to join room. Please try again.');
        }
      };

      const rejoinGame = async (gid) => {
        if (!db) return;
        const snap = await db.ref(`rooms/${gid}`).once('value');
        const rv = snap.val();
        if (rv && (rv.status === 'waiting' || rv.status === 'playing')) {
          setRoomId(gid);
          setView(rv.status === 'playing' ? 'game' : 'room');
        } else {
          setActiveGameId(null);
          localStorage.removeItem('cc_activegame');
          showModal('üìú Room Closed', 'This chronicle is no longer available. It may have ended or been closed.');
        }
      };

      const addAI = async () => {
        if (!db || !roomId) return;
        const curIds = Object.keys(roomData?.players || {});
        AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, 3).forEach(ai => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai));
      };

      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
        
        // Reset all refs for new game
        lastRoundRef.current = 0;
        scoredRoundRef.current = 0;
        debatedRoundRef.current = 0;
        processingRef.current = false;
        
        // Read players directly from Firebase to ensure all are included
        const roomSnap = await db.ref(`rooms/${roomId}/players`).once('value');
        const allPlayers = roomSnap.val() ? Object.values(roomSnap.val()) : [];
        
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        
        // Initialize scores for ALL players from Firebase
        const scores = {};
        allPlayers.forEach(p => { scores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
        
        await db.ref(`games/${roomId}`).set({ round: 1, phase: 'debate', path: [], scores, votes: {}, story: [{ text: arc.opening, type: 'opening', round: 0 }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, messages: {} });
        lastRoundRef.current = 1;
        addMsg('system', `üìñ ${arc.name} begins! Round 1/${CONFIG.TOTAL_ROUNDS}`);
        setTimeout(() => aiDebate(), 3000);
      };

      const aiDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => { const d = genAIDebate(ai.style); addMsg('chat', d.text, ai, d.choice); }, (i + 1) * 2500 + Math.random() * 4000);
        });
      };

      const phaseEnd = async () => {
        const g = gameRef.current;
        if (!db || !roomId || !g || processingRef.current) return;
        if (g.phase !== 'debate' && g.phase !== 'vote') return;
        
        processingRef.current = true;
        try {
          if (g.phase === 'debate') {
            await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
            addMsg('system', 'üó≥Ô∏è Voting begins!');
            players.filter(p => p.isAI).forEach((ai, i) => { setTimeout(async () => { try { await db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B'); } catch {} }, (i + 1) * 800); });
          } else if (g.phase === 'vote') {
            await calcResult();
          }
        } catch (e) {
          console.error('phaseEnd error:', e);
        } finally {
          processingRef.current = false;
        }
      };

      const calcResult = async () => {
        const g = gameRef.current;
        if (!db || !roomId || !g) return;
        
        const round = g.round;
        
        // Prevent duplicate scoring for the same round using separate ref
        if (scoredRoundRef.current >= round) return;
        scoredRoundRef.current = round;
        
        await new Promise(r => setTimeout(r, 500));
        const vs = await db.ref(`games/${roomId}/votes`).once('value');
        const cv = vs.val() || {};
        const cnt = { A: 0, B: 0 };
        Object.values(cv).forEach(v => { if (v === 'A') cnt.A++; else if (v === 'B') cnt.B++; });
        
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const rd = arc.rounds[round - 1];
        
        // Read current scores
        const ss = await db.ref(`games/${roomId}/scores`).once('value');
        const newScores = ss.val() || {};
        
        // Check for tie
        const isTie = cnt.A === cnt.B;
        let winner = null;
        let winOpt = null;
        let resultText = '';
        
        if (isTie) {
          // Tie - no winner, no score added, randomly pick path direction
          winner = Math.random() > 0.5 ? 'A' : 'B';
          winOpt = winner === 'A' ? rd?.a : rd?.b;
          resultText = `Tie vote (${cnt.A} vs ${cnt.B})! No consensus reached. Fate decides the path...`;
          addMsg('system', `‚öñÔ∏è Tie! No winner this round.`);
        } else {
          // Clear winner - add score to winners
          winner = cnt.A > cnt.B ? 'A' : 'B';
          winOpt = winner === 'A' ? rd?.a : rd?.b;
          resultText = `Council chose Option ${winner} (${cnt[winner]} vs ${cnt[winner === 'A' ? 'B' : 'A']})`;
          
          // Only add score when there's a clear winner - each voter gets score only once
          Object.entries(cv).forEach(([id, v]) => {
            if (v === winner && newScores[id]) {
              newScores[id].influence = (newScores[id].influence || 0) + 30;
              newScores[id].wins = (newScores[id].wins || 0) + 1;
            }
          });
          addMsg('system', `‚öñÔ∏è Option ${winner} wins!`);
        }
        
        const newPath = [...(g.path || []), winner];
        const newStory = [...(g.story || []), { text: resultText, type: 'choice', round, winner, isTie }, { text: winOpt?.text, type: 'consequence', round }];

        if (round >= CONFIG.TOTAL_ROUNDS) {
          const ending = arc.endings.default;
          // DON'T close room here - close when player exits
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: [...newStory, { text: ending, type: 'ending', round }], timerEnd: null, votes: {} });
          addMsg('system', 'üèÜ Chronicle Complete!');
          await recordToGL();
          
          // Read players directly from Firebase to ensure we have all players
          const roomSnap = await db.ref(`rooms/${roomId}/players`).once('value');
          const allPlayers = roomSnap.val() ? Object.values(roomSnap.val()) : [];
          
          const realCount = allPlayers.filter(p => !p.isAI).length;
          const aiCount = allPlayers.filter(p => p.isAI).length;
          
          // Save EXP for ALL real players who have scores
          for (const [pid, sc] of Object.entries(newScores)) {
            const p = allPlayers.find(x => x.id === pid);
            if (p && !p.isAI) {
              const earnedExp = (sc.influence || 0) + (sc.debates || 0);
              // Save to user history
              await db.ref(`userHistory/${pid}`).push().set({ 
                id: Date.now(), 
                timestamp: Date.now(), 
                theme, 
                path: newPath.join(''), 
                ending: ending.slice(0, 100) + '...', 
                datetime: new Date().toISOString(), 
                realPlayers: realCount, 
                aiPlayers: aiCount, 
                earnedExp, 
                roomId 
              });
              // Save EXP to player profile (even if 0, to track participation)
              if (earnedExp > 0) {
                await db.ref(`players/${pid}`).transaction(cur => {
                  if (!cur) return { name: p.name, avatar: p.avatar, exp: earnedExp };
                  return { ...cur, name: p.name, avatar: p.avatar, exp: (cur.exp || 0) + earnedExp };
                });
                console.log(`Saved ${earnedExp} EXP for player ${pid}`);
              }
            }
          }
        } else {
          const nextRd = round + 1;
          await db.ref(`games/${roomId}`).update({ round: nextRd, phase: 'debate', scores: newScores, path: newPath, story: [...newStory, { text: arc.rounds[nextRd - 1]?.context, type: 'context', round: nextRd }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, votes: {} });
          addMsg('system', `üìñ Round ${nextRd}/${CONFIG.TOTAL_ROUNDS}`);
          setMyVote(null);
          setTimeout(() => aiDebate(), 3000);
        }
      };

      const addMsg = async (type, text, sender = null, choice = null) => {
        if (db && roomId) await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() });
      };

      const submitDebate = async () => {
        if (!input.trim() || game?.phase !== 'debate') return;
        const c = input.toUpperCase().includes('A') ? 'A' : input.toUpperCase().includes('B') ? 'B' : null;
        await addMsg('chat', input, { id: player.id, name: player.name, avatar: player.avatar }, c);
        setInput('');
        
        // Only add debate points ONCE per round
        const currentRound = game?.round || 0;
        if (debatedRoundRef.current < currentRound) {
          debatedRoundRef.current = currentRound;
          const cd = game?.scores?.[player.id]?.debates || 0;
          await db.ref(`games/${roomId}/scores/${player.id}/debates`).set(cd + 10);
        }
      };

      const vote = async (c) => {
        if (game?.phase !== 'vote' || myVote) return;
        setMyVote(c);
        await db.ref(`games/${roomId}/votes/${player.id}`).set(c);
        addMsg('system', `${player.name} voted`);
      };

      // Confirm exit from game - show modal first
      const confirmExitGame = () => {
        if (game?.phase === 'ended') {
          // Game ended - exit directly
          doExitGame();
        } else {
          // Game in progress - confirm first (prevent double modal)
          if (modalShownRef.current) return;
          modalShownRef.current = true;
          showModal('‚ö†Ô∏è Leave Game?', 'Are you sure you want to leave? The game will continue without you.', () => {
            modalShownRef.current = false;
            doExitGame();
          });
        }
      };

      // Actually exit from game view
      const doExitGame = async () => {
        // Close modal first
        closeModal();
        modalShownRef.current = false;
        
        // Mark as exiting and intentional exit BEFORE any async operations
        exitingRef.current = true;
        intentionalExitRef.current = true;
        
        // Case C: Game ended - close room in Firebase
        if (game?.phase === 'ended' && db && roomId) {
          try { 
            await db.ref(`rooms/${roomId}`).update({ status: 'closed' }); 
          } catch (e) {
            console.log('Failed to close room:', e);
          }
        }
        
        // Reset all state and return to home
        fullReset();
      };

      // Confirm exit from room - show modal first
      const confirmReset = () => {
        if (modalShownRef.current) return;
        modalShownRef.current = true;
        showModal('‚ö†Ô∏è Leave Room?', 'Are you sure you want to leave? The room will be closed.', () => {
          modalShownRef.current = false;
          doReset();
        });
      };

      // Actually exit from room view (waiting status) - Case A: close room immediately
      const doReset = async () => {
        closeModal();
        modalShownRef.current = false;
        
        // Mark as exiting and intentional exit BEFORE any async operations
        exitingRef.current = true;
        intentionalExitRef.current = true;
        
        // Case A: Room not started (waiting) - close room immediately
        if (db && roomId && roomData?.status === 'waiting') {
          try { await db.ref(`rooms/${roomId}`).update({ status: 'closed' }); } catch {}
        }
        fullReset();
      };
      
      const resetSync = () => {
        fullReset();
      };

      const clearHistory = async () => {
        if (!db || !wallet) return;
        showModal('üóëÔ∏è Clear History', 'Clear all your chronicle history? This action cannot be undone.', async () => {
          await db.ref(`userHistory/${wallet}`).remove();
          setHist([]);
          closeModal();
        });
      };

      const fmtTime = s => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const shortAddr = a => a ? `${a.slice(0, 6)}...${a.slice(-4)}` : '';
      const getOpts = () => { if (!game || !roomData) return { a: null, b: null }; const rd = THEMES[roomData.theme]?.rounds[(game.round || 1) - 1]; return { a: rd?.a, b: rd?.b }; };
      const opts = getOpts();
      const votes = game?.votes || {};
      const themeData = roomData?.theme ? THEMES[roomData.theme] : null;

      // Modal rendering is handled by external Modal component

      const RulesModal = () => showRules && (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '1rem' }}>
          <div style={{ ...S.card, padding: '2rem', maxWidth: '500px', maxHeight: '80vh', overflowY: 'auto' }}>
            <h2 style={{ ...S.title, color: C.gold, marginBottom: '1.5rem', textAlign: 'center' }}>‚öúÔ∏è RULES ‚öúÔ∏è</h2>
            <div style={{ color: C.textSoft, lineHeight: 1.8, fontSize: '0.9rem' }}>
              <p style={{ marginBottom: '1rem', padding: '0.8rem', background: C.bgGlass, borderRadius: '8px', borderLeft: `3px solid ${C.gold}` }}><b>üéØ Goal:</b> Guide narrative through 5 rounds of decisions.</p>
              <p style={{ marginBottom: '1rem', padding: '0.8rem', background: C.bgGlass, borderRadius: '8px', borderLeft: `3px solid ${C.gold}` }}><b>üîó Entry:</b> Connect wallet + GenLayer transaction (0 GEN). One room per 2 minutes.</p>
              <p style={{ marginBottom: '1rem', padding: '0.8rem', background: C.bgGlass, borderRadius: '8px', borderLeft: `3px solid ${C.gold}` }}><b>‚è±Ô∏è Timing:</b> 2-8 players. AI joins after 60s. Room expires after 120s.</p>
              <p style={{ marginBottom: '1rem', padding: '0.8rem', background: C.bgGlass, borderRadius: '8px', borderLeft: `3px solid ${C.gold}` }}><b>‚≠ê Rewards:</b> Debate +10 EXP, Win vote +30 EXP. Results on GenLayer.</p>
            </div>
            <button onClick={() => setShowRules(false)} style={{ ...S.btn, ...S.goldBtn, width: '100%', padding: '0.9rem', marginTop: '1rem', borderRadius: '8px' }}>OK</button>
          </div>
        </div>
      );

      // HOME VIEW
      if (view === 'home') {
        return (
          <div style={{ minHeight: '100vh', background: `radial-gradient(ellipse at top, rgba(30,25,15,0.3), ${C.bg})` }}>
          <Modal show={modal.show} title={modal.title} message={modal.message} type={modal.type} onClose={closeModal} onConfirm={modal.onConfirm} />
          <RulesModal />
          <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.borderLight}`, background: 'rgba(5,5,7,0.8)' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}><span style={{ fontSize: '1.8rem' }} className="glow-icon">üìú</span><div><h1 style={{ ...S.title, color: C.gold, fontSize: '1.2rem' }}>CONSENSUS CHRONICLE</h1><p style={{ color: C.textMuted, fontSize: '0.65rem', letterSpacing: '0.2em' }}>SHAPE HISTORY TOGETHER</p></div></div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
              {player.name && <span style={{ color: C.textSoft, fontSize: '0.9rem' }}>{player.avatar} {player.name} ‚Ä¢ <span style={{ color: C.goldBright, fontWeight: 700 }}>‚≠ê{player.exp}</span></span>}
              {wallet ? <button onClick={disconnect} style={{ ...S.btn, ...S.ghostBtn, padding: '0.5rem 1rem', borderRadius: '20px', fontSize: '0.8rem' }}>üîó {shortAddr(wallet)}</button> : <button onClick={connectWallet} disabled={connecting} style={{ ...S.btn, ...S.goldBtn, padding: '0.6rem 1.2rem', borderRadius: '20px', fontSize: '0.85rem' }}>{connecting ? '...' : 'ü¶ä Connect'}</button>}
            </div>
          </header>
          <nav style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem', padding: '1rem', borderBottom: `1px solid ${C.borderLight}` }}>
            {[{ k: 'chronicles', l: 'üìú Chronicles' }, { k: 'rankings', l: 'üèÜ Rankings' }, { k: 'archive', l: 'üìö Archive' }].map(t => <button key={t.k} onClick={() => setTab(t.k)} style={{ ...S.btn, padding: '0.6rem 1.5rem', background: tab === t.k ? C.bgGlass : 'transparent', border: `1px solid ${tab === t.k ? C.border : 'transparent'}`, borderRadius: '6px', color: tab === t.k ? C.gold : C.textMuted, fontSize: '0.9rem' }}>{t.l}</button>)}
            <button onClick={() => setShowRules(true)} style={{ ...S.btn, padding: '0.6rem 1.5rem', background: 'transparent', border: `1px solid ${C.borderLight}`, borderRadius: '6px', color: C.goldMuted, fontSize: '0.9rem' }}>üìñ Rules</button>
          </nav>
          <main style={{ maxWidth: '1000px', margin: '0 auto', padding: '2rem' }}>
            {tab === 'chronicles' && (<>
              {!player.name ? (
                <div style={{ maxWidth: '400px', margin: '3rem auto', textAlign: 'center' }}>
                  <div style={{ fontSize: '4rem', marginBottom: '1rem' }} className="float-anim glow-icon">‚öúÔ∏è</div>
                  <h2 style={{ ...S.title, color: C.gold, marginBottom: '0.8rem' }}>Enter Your Name</h2>
                  <input type="text" placeholder="Your name..." style={{ width: '100%', padding: '1rem', fontSize: '1rem', background: C.bgCard, border: `2px solid ${C.border}`, borderRadius: '10px', color: C.text, outline: 'none', textAlign: 'center' }} onKeyDown={e => { if (e.key === 'Enter' && e.target.value.trim()) { const n = e.target.value.trim(); setPlayer(p => ({ ...p, name: n })); if (wallet) { localStorage.setItem('cc_player', JSON.stringify({ ...player, name: n })); db?.ref(`players/${wallet}`).update({ name: n, avatar: player.avatar }); } } }} />
                  <p style={{ marginTop: '0.5rem', color: C.textMuted, fontSize: '0.8rem' }}>Press Enter</p>
                </div>
              ) : (<>
                
                {rooms.length > 0 && (
                  <div style={{ marginBottom: '2rem' }}>
                    <h3 style={{ ...S.title, color: C.goldLight, marginBottom: '1rem' }}>üö™ Open Rooms</h3>
                    {rooms.map(r => (
                      <div key={r.id} style={{ ...S.card, display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '1rem', marginBottom: '0.8rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><span style={{ fontSize: '2rem' }}>{THEMES[r.theme]?.icon}</span><div><div style={{ ...S.title, color: C.text }}>{THEMES[r.theme]?.name}</div><div style={{ fontSize: '0.8rem', color: C.textMuted }}>{Object.keys(r.players || {}).length}/{CONFIG.ROOM_SIZE.max} players</div></div></div>
                        <button onClick={() => joinRoom(r.id)} disabled={loading} style={{ ...S.btn, ...S.goldBtn, padding: '0.6rem 1.5rem', borderRadius: '6px', opacity: loading ? 0.5 : 1 }}>{loading ? '...' : 'Join'}</button>
                      </div>
                    ))}
                  </div>
                )}
                
                <h3 style={{ ...S.title, color: C.goldLight, marginBottom: '1.2rem', textAlign: 'center' }}>‚öúÔ∏è Create New Chronicle ‚öúÔ∏è</h3>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))', gap: '1.2rem' }}>
                  {Object.entries(THEMES).map(([k, t]) => (
                    <button key={k} onClick={() => createRoom(k)} disabled={loading} style={{ ...S.card, display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '2rem 1.2rem', cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.5 : 1, transition: 'all 0.3s' }} onMouseOver={e => { if (!loading) e.currentTarget.style.borderColor = C.gold; }} onMouseOut={e => e.currentTarget.style.borderColor = C.border}>
                      <span style={{ fontSize: '3.5rem', marginBottom: '0.8rem' }} className="glow-icon">{t.icon}</span>
                      <span style={{ ...S.title, fontSize: '1rem', color: C.gold, marginBottom: '0.3rem' }}>{t.name}</span>
                      <span style={{ fontSize: '0.8rem', color: C.textMuted, textAlign: 'center' }}>{t.tagline}</span>
                    </button>
                  ))}
                </div>
                {loading && <div style={{ textAlign: 'center', padding: '1.5rem', color: C.gold, animation: 'pulse 1.5s infinite' }}>‚è≥ Awaiting transaction...</div>}
              </>)}
            </>)}
            {tab === 'rankings' && (
              <div style={{ maxWidth: '600px', margin: '0 auto' }}>
                <h2 style={{ ...S.title, color: C.gold, textAlign: 'center', marginBottom: '1.5rem' }}>üèÜ Leaderboard</h2>
                {lb.length === 0 ? <p style={{ textAlign: 'center', color: C.textMuted, padding: '3rem' }}>No records yet</p> : lb.map((e, i) => (
                  <div key={e.id || i} style={{ ...S.card, display: 'flex', alignItems: 'center', gap: '1rem', padding: '0.9rem 1.2rem', marginBottom: '0.6rem', background: i === 0 ? `linear-gradient(135deg, rgba(212,175,55,0.15), ${C.bgCard})` : C.bgCard, borderColor: i === 0 ? C.gold : C.border }}>
                    <span style={{ ...S.title, fontWeight: 700, color: i < 3 ? C.goldBright : C.textMuted, width: '2rem' }}>#{i + 1}</span>
                    <span style={{ fontSize: '1.5rem' }}>{e.avatar || 'üé≠'}</span>
                    <div style={{ flex: 1 }}><div style={{ fontWeight: 600 }}>{e.name || 'Unknown'}</div><div style={{ fontSize: '0.7rem', color: C.textMuted }}>{shortAddr(e.id)}</div></div>
                    <span style={{ ...S.title, color: C.goldBright, fontWeight: 700, fontSize: '1.1rem' }}>‚≠ê {e.exp || 0}</span>
                  </div>
                ))}
              </div>
            )}
            {tab === 'archive' && (
              <div style={{ maxWidth: '700px', margin: '0 auto' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                  <h2 style={{ ...S.title, color: C.gold }}>üìö Your History</h2>
                  {hist.length > 0 && <button onClick={clearHistory} style={{ ...S.btn, ...S.ghostBtn, padding: '0.4rem 0.8rem', borderRadius: '5px', fontSize: '0.75rem', borderColor: C.error, color: C.error }}>Clear</button>}
                </div>
                {!wallet ? <p style={{ textAlign: 'center', color: C.textMuted, padding: '3rem' }}>Connect wallet</p> : hist.length === 0 ? <p style={{ textAlign: 'center', color: C.textMuted, padding: '3rem' }}>No history</p> : hist.map((g, i) => (
                  <div key={g.id || i} style={{ ...S.card, padding: '1rem', marginBottom: '0.8rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 600 }}>{THEMES[g.theme]?.icon} {THEMES[g.theme]?.name}</span><span style={{ fontSize: '0.75rem', color: C.textMuted }}>{new Date(g.timestamp).toLocaleDateString()}</span></div>
                    <div style={{ fontSize: '0.8rem', color: C.textSoft, marginBottom: '0.5rem' }}>{g.realPlayers || 1}+{g.aiPlayers || 0}AI ‚Ä¢ <span style={{ color: C.goldBright, fontWeight: 600 }}>+{g.earnedExp || 0} EXP</span> ‚Ä¢ {g.path?.split('').map((c, j) => <span key={j} style={{ display: 'inline-block', padding: '0.1rem 0.35rem', margin: '0 0.1rem', background: c === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '3px', color: c === 'A' ? C.optALight : C.optBLight, fontSize: '0.7rem' }}>{c}</span>)}</div>
                    <p style={{ fontSize: '0.85rem', color: C.textMuted, fontStyle: 'italic' }}>"{g.ending}"</p>
                  </div>
                ))}
              </div>
            )}
          </main>
        </div>
        );
      }

      // ROOM VIEW
      if (view === 'room') {
        const age = roomData ? Math.floor((Date.now() - roomData.createdAt) / 1000) : 0;
        const remainingMin = Math.floor(roomTimer / 60);
        const remainingSec = roomTimer % 60;
        return (
          <div style={{ minHeight: '100vh', background: `radial-gradient(ellipse at center, rgba(30,25,15,0.2), ${C.bg})` }}>
            <Modal show={modal.show} title={modal.title} message={modal.message} type={modal.type} onClose={closeModal} onConfirm={modal.onConfirm} />
            <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.borderLight}`, background: 'rgba(5,5,7,0.8)' }}>
              <button onClick={confirmReset} style={{ ...S.btn, ...S.ghostBtn, padding: '0.5rem 1rem', borderRadius: '6px', fontSize: '0.85rem' }}>‚Üê Back</button>
              <div><span style={{ fontSize: '1.5rem', marginRight: '0.5rem' }}>{themeData?.icon}</span><span style={{ ...S.title, color: C.gold }}>{themeData?.name}</span></div>
              <span style={{ color: C.textMuted }}>{player.avatar} {player.name}</span>
            </header>
            <div style={{ maxWidth: '600px', margin: '0 auto', padding: '2.5rem 2rem' }}>
              <div style={{ textAlign: 'center', marginBottom: '2rem' }}>
                <div style={{ fontSize: '5rem', marginBottom: '1rem' }} className="float-anim glow-icon">{themeData?.icon}</div>
                <h2 style={{ ...S.title, color: C.gold, fontSize: '1.6rem', marginBottom: '0.4rem' }}>{themeData?.name}</h2>
                <p style={{ color: C.textMuted, fontStyle: 'italic', marginBottom: '1rem' }}>{themeData?.tagline}</p>
              </div>
              <div style={{ textAlign: 'center', marginBottom: '1.5rem', padding: '1rem', background: roomTimer <= 30 ? `${C.error}15` : `${C.gold}10`, borderRadius: '10px', border: `1px solid ${roomTimer <= 30 ? C.error : C.gold}40` }}>
                <p style={{ color: roomTimer <= 30 ? C.error : C.gold, fontWeight: 600, marginBottom: '0.3rem' }}>‚è∞ Please start the game within 2 minutes</p>
                <p style={{ ...S.title, fontSize: '1.8rem', color: roomTimer <= 30 ? C.error : C.goldBright }}>{remainingMin}:{remainingSec.toString().padStart(2, '0')}</p>
                <p style={{ color: C.textMuted, fontSize: '0.8rem', marginTop: '0.3rem' }}>Room will close when timer expires</p>
              </div>
              {age > 60 && <div style={{ textAlign: 'center', marginBottom: '1rem', padding: '0.7rem', background: `${C.gold}10`, borderRadius: '8px', border: `1px solid ${C.border}` }}><p style={{ color: C.goldMuted }}>‚è≥ AI joining soon...</p></div>}
              <h3 style={{ ...S.title, color: C.goldMuted, marginBottom: '1rem', fontSize: '0.85rem', textAlign: 'center', letterSpacing: '0.1em' }}>PLAYERS ({players.length}/{CONFIG.ROOM_SIZE.max})</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.8rem', marginBottom: '2rem' }}>
                {players.map(p => (
                  <div key={p.id} style={{ ...S.card, display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1.2rem 0.8rem', background: p.id === player.id ? `linear-gradient(135deg, rgba(212,175,55,0.1), ${C.bgCard})` : C.bgCard, borderColor: p.id === player.id ? C.gold : C.border, position: 'relative' }}>
                    <span style={{ fontSize: '2rem', marginBottom: '0.4rem' }}>{p.avatar}</span>
                    <span style={{ fontSize: '0.8rem', color: C.text, textAlign: 'center' }}>{p.name}</span>
                    {p.isAI && <span style={{ position: 'absolute', top: '0.4rem', left: '0.4rem', fontSize: '0.55rem', padding: '0.1rem 0.4rem', background: C.optB, borderRadius: '3px', color: '#fff' }}>AI</span>}
                    {p.id === roomData?.host && <span style={{ position: 'absolute', top: '0.4rem', right: '0.4rem', fontSize: '0.55rem', padding: '0.1rem 0.4rem', background: C.gold, borderRadius: '3px', color: '#000' }}>HOST</span>}
                  </div>
                ))}
              </div>
              {player.id === roomData?.host && (<>
                <button onClick={startGame} disabled={players.length < CONFIG.ROOM_SIZE.min} style={{ ...S.btn, width: '100%', padding: '1rem', fontSize: '1rem', borderRadius: '10px', marginBottom: '0.8rem', ...(players.length >= CONFIG.ROOM_SIZE.min ? S.goldBtn : S.ghostBtn) }}>{players.length >= CONFIG.ROOM_SIZE.min ? '‚öîÔ∏è Start Game' : `Need ${CONFIG.ROOM_SIZE.min - players.length} more`}</button>
                <button onClick={addAI} style={{ ...S.btn, ...S.ghostBtn, width: '100%', padding: '0.7rem', borderRadius: '8px' }}>ü§ñ Add AI</button>
              </>)}
            </div>
          </div>
        );
      }

      // GAME VIEW
      return (
        <div style={{ height: '100vh', background: C.bg, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
          <Modal show={modal.show} title={modal.title} message={modal.message} type={modal.type} onClose={closeModal} onConfirm={modal.onConfirm} />
          <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.7rem 1.5rem', background: 'rgba(5,5,7,0.9)', borderBottom: `1px solid ${C.borderLight}`, height: '55px', flexShrink: 0 }}>
            <button onClick={confirmExitGame} style={{ ...S.btn, ...S.ghostBtn, padding: '0.4rem 0.8rem', borderRadius: '5px', fontSize: '0.75rem' }}>{game?.phase === 'ended' ? '‚Üê Exit' : '‚Üê Leave'}</button>
            <div style={{ textAlign: 'center' }}><div style={{ fontSize: '0.65rem', color: C.textMuted, letterSpacing: '0.1em' }}>ROUND {game?.round || 1}/{CONFIG.TOTAL_ROUNDS}</div><div style={{ ...S.title, fontSize: '0.85rem', color: game?.phase === 'debate' ? C.goldLight : game?.phase === 'vote' ? C.success : C.gold }}>{game?.phase === 'debate' && 'üí¨ DEBATE'}{game?.phase === 'vote' && 'üó≥Ô∏è VOTE'}{game?.phase === 'ended' && 'üìú COMPLETE'}</div></div>
            <div style={{ ...S.title, fontSize: '1.8rem', fontWeight: 700, color: timer <= 10 && game?.phase !== 'ended' ? C.error : C.gold }}>{game?.phase === 'ended' ? '‚Äî' : fmtTime(timer)}</div>
            <div style={{ textAlign: 'right' }}><div style={{ fontSize: '0.6rem', color: C.textMuted, letterSpacing: '0.1em' }}>SCORE</div><div style={{ ...S.title, fontSize: '1.2rem', fontWeight: 700, color: C.goldBright }}>{(game?.scores?.[player.id]?.influence || 0) + (game?.scores?.[player.id]?.debates || 0)}</div></div>
          </header>
          <div style={{ flex: 1, display: 'flex', gap: '0.8rem', padding: '0.8rem', minHeight: 0 }}>
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '0.8rem', minWidth: 0 }}>
              <div style={{ ...S.card, flex: 1, padding: '1rem', overflowY: 'auto', minHeight: 0 }}>
                <h3 style={{ ...S.title, color: C.gold, marginBottom: '0.8rem', fontSize: '0.9rem' }}>{themeData?.icon} {themeData?.name}</h3>
                {(game?.story || []).map((s, i) => (
                  <div key={i} style={{ marginBottom: '0.8rem' }}>
                    {s.type === 'opening' && <p style={{ color: C.goldLight, fontStyle: 'italic', lineHeight: 1.7, fontSize: '0.9rem' }}>{s.text}</p>}
                    {s.type === 'context' && <div style={{ borderLeft: `3px solid ${C.gold}`, paddingLeft: '1rem', marginTop: '1rem' }}><span style={{ ...S.title, display: 'inline-block', background: `${C.gold}20`, padding: '0.2rem 0.5rem', borderRadius: '4px', fontSize: '0.65rem', color: C.gold, marginBottom: '0.4rem' }}>R{s.round}</span><p style={{ color: C.textSoft, lineHeight: 1.6, fontSize: '0.85rem' }}>{s.text}</p></div>}
                    {s.type === 'choice' && <p style={{ color: s.isTie ? C.goldMuted : C.success, lineHeight: 1.5, fontSize: '0.85rem', fontWeight: 600 }}>{s.isTie ? '‚öñÔ∏è' : '‚öîÔ∏è'} {s.text}</p>}
                    {s.type === 'consequence' && <p style={{ color: C.textSoft, lineHeight: 1.6, fontSize: '0.85rem', paddingLeft: '1rem', borderLeft: `2px solid ${C.borderLight}`, fontStyle: 'italic' }}>"{s.text}"</p>}
                    {s.type === 'ending' && <div style={{ marginTop: '1rem', padding: '1rem', background: `linear-gradient(135deg, ${C.gold}10, transparent)`, borderRadius: '10px', border: `1px solid ${C.border}` }}><p style={{ ...S.title, color: C.gold, lineHeight: 1.7, fontSize: '0.9rem' }}>üìú {s.text}</p></div>}
                  </div>
                ))}
              </div>
              {(game?.phase === 'debate' || game?.phase === 'vote') && opts.a && (
                <div style={{ ...S.card, padding: '0.8rem', flexShrink: 0 }}>
                  <h4 style={{ ...S.title, textAlign: 'center', marginBottom: '0.8rem', color: C.goldMuted, fontSize: '0.8rem', letterSpacing: '0.1em' }}>‚öîÔ∏è CHOOSE ‚öîÔ∏è</h4>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.8rem' }}>
                    {[{ k: 'A', o: opts.a, c: C.optA, cl: C.optALight }, { k: 'B', o: opts.b, c: C.optB, cl: C.optBLight }].map(({ k, o, c, cl }) => (
                      <div key={k} onClick={() => game?.phase === 'vote' && vote(k)} style={{ padding: '1rem', borderRadius: '10px', border: `2px solid ${myVote === k ? cl : `${c}50`}`, background: myVote === k ? `${c}15` : `${c}08`, cursor: game?.phase === 'vote' && !myVote ? 'pointer' : 'default', opacity: myVote && myVote !== k ? 0.4 : 1, transition: 'all 0.3s', position: 'relative' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}><span style={{ ...S.title, fontWeight: 700, color: cl, fontSize: '0.95rem' }}>{k}</span><span style={{ fontSize: '0.65rem', padding: '0.15rem 0.5rem', background: `${c}30`, borderRadius: '4px', color: cl }}>{o?.tag}</span></div>
                        <p style={{ lineHeight: 1.5, fontSize: '0.8rem', color: C.textSoft }}>{o?.text}</p>
                        {game?.phase === 'vote' && <div style={{ marginTop: '0.7rem', textAlign: 'center', ...S.title, fontSize: '1.1rem', fontWeight: 700, color: C.goldBright }}>{Object.values(votes).filter(v => v === k).length} votes</div>}
                        {myVote === k && <div style={{ position: 'absolute', top: '0.5rem', right: '0.5rem', color: cl, fontSize: '1rem' }}>‚úì</div>}
                      </div>
                    ))}
                  </div>
                </div>
              )}
              {game?.phase === 'ended' && (
                <div style={{ ...S.card, padding: '1.5rem', textAlign: 'center', background: `linear-gradient(135deg, ${C.gold}10, ${C.bgCard})`, borderColor: C.gold, flexShrink: 0 }}>
                  <h2 style={{ ...S.title, fontSize: '1.3rem', marginBottom: '1rem', color: C.gold }}>üèÜ COMPLETE üèÜ</h2>
                  <div style={{ maxWidth: '320px', margin: '0 auto 1rem' }}>
                    {Object.entries(game?.scores || {}).map(([id, sc]) => ({ p: players.find(x => x.id === id), t: (sc.influence || 0) + (sc.debates || 0) })).sort((a, b) => b.t - a.t).map((r, i) => (
                      <div key={r.p?.id || i} style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', padding: '0.6rem 1rem', marginBottom: '0.4rem', background: i === 0 ? `${C.gold}20` : C.bgGlass, borderRadius: '6px', border: i === 0 ? `1px solid ${C.gold}40` : 'none' }}>
                        <span style={{ ...S.title, fontWeight: 700, color: i < 3 ? C.goldBright : C.textMuted }}>{i + 1}</span><span style={{ fontSize: '1.3rem' }}>{r.p?.avatar}</span><span style={{ flex: 1, textAlign: 'left' }}>{r.p?.name}</span><span style={{ ...S.title, fontWeight: 600, color: C.goldBright }}>{r.t}</span>
                      </div>
                    ))}
                  </div>
                  <button onClick={doExitGame} style={{ ...S.btn, ...S.goldBtn, padding: '0.8rem 2rem', borderRadius: '8px' }}>Exit & Close Room</button>
                </div>
              )}
            </div>
            <div style={{ width: '260px', display: 'flex', flexDirection: 'column', ...S.card, overflow: 'hidden' }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.3rem', padding: '0.5rem', borderBottom: `1px solid ${C.borderLight}`, flexShrink: 0 }}>
                {players.map(p => {
                  const pVote = votes[p.id];
                  const voteColor = pVote === 'A' ? C.optA : pVote === 'B' ? C.optB : null;
                  const voteLightColor = pVote === 'A' ? C.optALight : pVote === 'B' ? C.optBLight : null;
                  return (
                    <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '0.2rem', padding: '0.2rem 0.5rem', background: pVote ? `${voteColor}20` : C.bgGlass, borderRadius: '12px', fontSize: '0.7rem', border: pVote ? `1px solid ${voteColor}50` : `1px solid ${C.borderLight}` }}>
                      <span>{p.avatar}</span>
                      <span style={{ maxWidth: '40px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', color: C.textSoft }}>{p.name}</span>
                      {pVote && <span style={{ color: voteLightColor, fontWeight: 700, marginLeft: '0.2rem' }}>{pVote}</span>}
                    </div>
                  );
                })}
              </div>
              <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem', minHeight: 0 }}>
                {msgs.map((m, i) => (
                  <div key={i} style={{ marginBottom: '0.4rem', fontSize: '0.75rem' }}>
                    {m.type === 'system' ? <div style={{ color: C.goldMuted, fontStyle: 'italic', padding: '0.2rem 0' }}>{m.text}</div> : (
                      <div style={{ background: C.bgGlass, borderRadius: '8px', padding: '0.5rem 0.6rem', border: `1px solid ${C.borderLight}` }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.2rem' }}><span style={{ color: C.goldLight, fontWeight: 600, fontSize: '0.7rem' }}>{m.sender?.avatar} {m.sender?.name}</span>{m.choice && <span style={{ fontSize: '0.6rem', padding: '0.1rem 0.3rem', background: m.choice === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '3px', color: m.choice === 'A' ? C.optALight : C.optBLight }}>{m.choice}</span>}</div>
                        <div style={{ color: C.textSoft, lineHeight: 1.4 }}>{m.text}</div>
                      </div>
                    )}
                  </div>
                ))}
                <div ref={msgsEndRef} />
              </div>
              {game?.phase === 'debate' && (
                <div style={{ padding: '0.5rem', borderTop: `1px solid ${C.borderLight}`, flexShrink: 0 }}>
                  <div style={{ display: 'flex', gap: '0.3rem', marginBottom: '0.3rem' }}>
                    <input type="text" value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && submitDebate()} placeholder="Your opinion..." style={{ flex: 1, padding: '0.5rem 0.7rem', background: C.bgGlass, border: `1px solid ${C.borderLight}`, borderRadius: '6px', color: C.text, fontSize: '0.75rem', outline: 'none' }} />
                    <button onClick={submitDebate} style={{ ...S.btn, ...S.goldBtn, padding: '0.5rem 0.8rem', borderRadius: '6px', fontSize: '0.7rem' }}>Send</button>
                  </div>
                  <div style={{ display: 'flex', gap: '0.3rem' }}>
                    <button onClick={() => setInput('I support A: ')} style={{ flex: 1, ...S.btn, padding: '0.25rem', background: `${C.optA}15`, border: `1px solid ${C.optA}30`, borderRadius: '5px', color: C.optALight, fontSize: '0.65rem' }}>For A</button>
                    <button onClick={() => setInput('I support B: ')} style={{ flex: 1, ...S.btn, padding: '0.25rem', background: `${C.optB}15`, border: `1px solid ${C.optB}30`, borderRadius: '5px', color: C.optBLight, fontSize: '0.65rem' }}>For B</button>
                  </div>
                </div>
              )}
              {game?.phase === 'vote' && !myVote && <div style={{ padding: '0.8rem', textAlign: 'center', background: `${C.gold}10`, flexShrink: 0 }}><p style={{ ...S.title, color: C.gold, fontSize: '0.8rem' }}>‚è≥ Vote now</p></div>}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
